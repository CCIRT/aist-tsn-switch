# Copyright (c) 2025 National Institute of Advanced Industrial Science and Technology (AIST)
# All rights reserved.
# This software is released under the MIT License.
# http://opensource.org/licenses/mit-license.php

import copy
import ipaddress
import pyxsdb
import sys
import time
from typing import Union, List, Tuple, TextIO, Dict, TypeVar
from .device_property import TsnEfccAddressTable

TFrame = TypeVar('Frame', bound='Frame')

_PROT_UDP = 1
_PROT_RAW = 0

class Frame():
    """Defines a frame property that is generated by EFCrafter.
    Frame class provides user-friendly interface to define sending frames.

    Example:

    1. Create a RAW frame with 72B payload::

        >>> frame00 = Frame('Frame0').ether(4, 1).payload(72)
        >>> print(frame00)
        Frame0.ETHER(dst=4, src=1).Payload(length=72)

    2. Create a VLAN-tagged RAW frame with 72B payload::

        >>> frame01 = Frame('Frame1').ether(4, 1).vlan(1, 3).payload(72)
        >>> print(frame01)
        Frame1.ETHER(dst=4, src=1).VLAN(id=1, pcp=3).Payload(length=72)

    3. Create a VLAN-tagged UDP frame with 72B payload. If generating UDP frames, both of ipv4 and udp function must be called::

        >>> frame02 = Frame('Frame2').ether(4, 1).vlan(1, 2).ipv4(14, 11).udp(1234, 0xc000).payload(72)
        >>> print(frame02)
        Frame2.ETHER(dst=4, src=1).VLAN(id=1, pcp=2).IPV4(dst=14, src=11).UDP(dst=1234, src=49152).Payload(length=72)

    4. Create an EOL frame. EOL frame is a marker to denotes the end of frame sequence. The length and other information is ignored in EOL frame::

        >>> frame03 = Frame.eol()
        >>> print(frame03)
        EOL())
    """

    def __init__(self, name: str = ''):
        self._name = name
        self._vlan_id = None
        self._additional_wait = 0
        self._non_eol = 1
        self._nop = 0
        self._no_magic = 0
        self._protocol = None
        self._pcp = None
        self._dst_mac_idx = None
        self._dst_ip_idx = None
        self._dst_port = None
        self._src_mac_idx = None
        self._src_ip_idx = None
        self._src_port = None
        self._frame_length = None

    @classmethod
    def eol(cls) -> TFrame:
        """Generates EOL (end-of-line) frame object.

        Returns:
            Frame: EOL Frame object.
        """
        obj = cls('EOL')
        obj._vlan_id = 0
        obj._additional_wait = 0
        obj._non_eol = 0   # eol
        obj._nop = 0
        obj._no_magic = 0
        obj._protocol = 0
        obj._pcp = 0
        obj._dst_mac_idx = 0
        obj._dst_ip_idx = 0
        obj._dst_port = 0
        obj._src_mac_idx = 0
        obj._src_ip_idx = 0
        obj._src_port = 0
        obj._frame_length = 0

        return obj

    def clone(self, name: str = ''):
        """Returns copy of current object

        Args:
            name (str): Name of the cloned frame

        Returns:
            Frame: EOL Frame object.
        """
        obj = copy.deepcopy(self)
        if name != '':
            obj._name = name
        return obj

    def ether(self, dst: int, src: int) -> TFrame:
        """Set MAC address pair.

        Set MAC address pair of Frame.
        The Frame object manages the index of MAC address (int), instead of MAC address (aa:bb:cc:dd:ee:ff).
        The MAC index is parsed to address with EFCrafter's internal LUT.

        Args:
            dst (int): The index of destination MAC address (0-255).
            src (int): The index of source MAC address (0-255).

        Returns:
            Frame: self
        """
        self._dst_mac_idx = dst
        self._src_mac_idx = src
        self._protocol = _PROT_RAW
        return self

    def ipv4(self, dst: int, src: int) -> TFrame:
        """Set IPv4 address pair.

        Set IPv4 address pair of Frame.
        The Frame object manages the index of IPv4 address (int), instead of IPv4 address (xxx.yyy.zzz.www).
        The IPv4 index is parsed to address with EFCrafter's internal LUT.

        Args:
            dst (int): The index of destination IPv4 address (0-255).
            src (int): The index of source IPv4 address (0-255).

        Returns:
            Frame: self
        """
        self._dst_ip_idx = dst
        self._src_ip_idx = src
        return self

    def udp(self, dst: int, src: int) -> TFrame:
        """Set UDP port pair.

        Set UDP port pair of Frame.
        If UDP port is set, the frame is treated as an UDP frame.
        Otherwise, the frame is treated as a RAW frame.

        Args:
            dst (int): destination UDP port value (0-65535).
            src (int): source UDP port value (0-65535).

        Returns:
            Frame: self
        """
        self._dst_port = dst
        self._src_port = src
        self._protocol = _PROT_UDP
        return self

    def vlan(self, vlan_id: int, pcp: int) -> TFrame:
        """Set VLAN ID and PCP field value.

        Set VLAN ID and PCP field value.
        If VLAN ID is set, the VLAN tag is added to frame.
        Otherwise, the Frame has no VLAN tag.

        Args:
            vlan_id (int): VLAN ID (0-4095)
            pcp (int): PCP (Priority Code Point) value (0-7)

        Returns:
            Frame: self
        """
        self._vlan_id = vlan_id
        self._pcp = pcp
        return self

    def payload(self, length: int) -> TFrame:
        """Set payload length of Frame.

        The total length of Frame is calculated as shown below.

        - UDP Frame: EtherHeader (14) + VLAN Header (8, if existed) + IPv4 header (20) + UDP Header (8) + payload
        - RAW Frame: EtherHeader (14) + VLAN Header (8, if existed) + IPv4 header (20) + payload

        If this frame is a regular frame, the sum of length between IPv4 header and payload cannot exceeds MTU (1500).
        If this frame is a nop frame, length can be any 16-bit value without restriction.

        Args:
            length (int): Payload length (0-65535). If this frame is a regular frame, the maximum value is limited by MTU.

        Returns:
            Frame: self
        """
        self._frame_length = length
        return self

    def nop(self) -> TFrame:
        """Mark this frame as NOP frame.

        Returns:
            Frame: self
        """
        self._nop = 1
        return self

    def no_magic(self) -> TFrame:
        """Mark this frame as no magic frame.

        Returns:
            Frame: self
        """
        self._no_magic = 1
        return self

    def additional_wait(self, val: int) -> TFrame:
        """Add an additional delay cycles after frame transfer.

        Args:
            val (int): Additional delay cycles (0-127)

        Returns:
            Frame: self
        """
        self._additional_wait = val
        return self

    def get_length(self) -> Tuple[int, int]:
        """Returns frame length

        Returns:
            (int, int): Returns the length of current frame. This function returns 2 types of length.
                1. L2 length: Frame length between Ethernet header and payload
                2. L7 length: Payload length.
        """
        self._validate()
        l7_length = self._frame_length
        l2_length = 38  # Ethernet Header (14) + IPv4 Header (20) + FCS (4)
        if self._has_vlan():
            l2_length += 4
        if self._protocol == _PROT_UDP:
            l2_length += 8   # UDP Header
        l2_length += l7_length  # payload

        return l2_length, l7_length


    def __str__(self) -> str:
        self._validate()

        if self.is_eol():
            return 'EOL()'

        frame_str = f'{self._name}'
        if self._name == '':
            frame_str = 'Frame'

        frame_str += f'.ETHER(dst={self._dst_mac_idx}, src={self._src_mac_idx})'
        frame_str += f'.IPV4(dst={self._dst_ip_idx}, src={self._src_ip_idx})'

        if self._has_vlan():
            frame_str += f'.VLAN(id={self._vlan_id}, pcp={self._pcp})'

        if self._protocol == _PROT_UDP:
            frame_str += f'.UDP(dst={self._dst_port}, src={self._src_port})'

        # payload
        frame_str += f'.Payload(length={self._frame_length})'

        if self._nop == 1:
            frame_str += f'.Nop()'

        if self._additional_wait != 0:
            frame_str += f'.AdditionalWait({self._additional_wait})'

        if self._no_magic == 1:
            frame_str += f'.NoMagicWord()'

        return frame_str

    def reg_format(self) -> List[int]:
        """Returns register format of Frame object.

        Returns:
            List[int]: Register format of frame information (int32 x4).
        """
        self._validate()
        reg = [0, 0, 0, 0]

        def mask_bits(val, start, length):
            masked = val & ((1 << length) - 1)
            return masked << start

        reg[0] |= mask_bits(self._frame_length, 0, 16)
        reg[1] |= mask_bits(self._src_ip_idx, 0, 8)
        reg[2] |= mask_bits(self._dst_ip_idx, 0, 8)

        if self._protocol == _PROT_UDP:
            reg[0] |= mask_bits(self._src_port, 16, 16)
            reg[1] |= mask_bits(self._dst_port, 16, 16)

        reg[1] |= mask_bits(self._src_mac_idx, 8, 8)
        reg[2] |= mask_bits(self._dst_mac_idx, 8, 8)

        if self._has_vlan():
            reg[3] = self._vlan_id
            reg[2] = reg[2] | (self._pcp << 16) | (1 << 19) # is_vlan=1
        reg[2] = reg[2] | (self._protocol << 20)
        reg[2] = reg[2] | (self._nop << 22)
        reg[2] = reg[2] | (self._non_eol << 23)
        reg[2] = reg[2] | (self._additional_wait << 24)
        reg[2] = reg[2] | (self._no_magic << 31)
        return reg

    def init_from_register(self, regval: List[int]) -> TFrame:
        """Initialize frame object from FPGA register values.

        Args:
            regval (List[int]): Register format of frame information (int32 x4).

        Returns:
            Frame: self
        """
        if len(regval) != 4:
            raise ValueError('regval length must be 4')

        def get_bits(val, start, length):
            return (val >> start) & ((1 << (length)) - 1)

        self._frame_length = get_bits(regval[0], 0, 16)
        self._src_port = get_bits(regval[0], 16, 16)
        self._src_ip_idx = get_bits(regval[1], 0, 8)
        self._src_mac_idx = get_bits(regval[1], 8, 8)
        self._dst_port = get_bits(regval[1], 16, 16)
        self._dst_ip_idx = get_bits(regval[2], 0, 8)
        self._dst_mac_idx = get_bits(regval[2], 8, 8)
        is_vlan = get_bits(regval[2], 19, 1)
        if is_vlan:
            self._vlan_id = get_bits(regval[3], 0, 12)
            self._pcp = get_bits(regval[2], 16, 3)
        else:
            self._vlan_id = None
            self._pcp = None
        self._protocol = get_bits(regval[2], 20, 2)
        self._nop = get_bits(regval[2], 22, 1)
        self._non_eol = get_bits(regval[2], 23, 1)
        self._additional_wait = get_bits(regval[2], 24, 7)
        self._no_magic = get_bits(regval[2], 31, 1)

        return self

    def is_eol(self) -> bool:
        """Returns whether this frame is EOL or not.

        Returns:
            bool: If this frame is EOL, returns True.
        """
        return self._non_eol == 0

    def _has_vlan(self):
        return self._vlan_id is not None

    def _validate(self):
        if self._protocol == _PROT_RAW:
            targets = ['_protocol', '_dst_mac_idx', '_src_mac_idx', '_dst_ip_idx', '_src_ip_idx', '_frame_length']
            for t in targets:
                if getattr(self, t) is None:
                    raise ValueError(f'{t} field is not set')
            self._dst_port = 0
            self._src_port = 0
        else:
            targets = ['_protocol', '_dst_mac_idx', '_dst_ip_idx', '_dst_port', '_src_mac_idx', '_src_ip_idx', '_src_port', '_frame_length']
            for t in targets:
                if getattr(self, t) is None:
                    raise ValueError(f'{t} field is not set')

        ranges = [('_vlan_id', 12),
                  ('_additional_wait', 7),
                  ('_non_eol', 1),
                  ('_nop', 1),
                  ('_no_magic', 1),
                  ('_protocol', 2),
                  ('_pcp', 3),
                  ('_dst_mac_idx', 8),
                  ('_dst_ip_idx', 8),
                  ('_dst_port', 16),
                  ('_src_mac_idx', 8),
                  ('_src_ip_idx', 8),
                  ('_src_port', 16),
                  ('_frame_length', 16)]

        for r in ranges:
            val = getattr(self, r[0])
            if val is not None and val >= (1 << r[1]):
                raise ValueError(f'{r[0]} field value is too large. val={val}, max_val={(1<<r[1])-1}')


class EFCrafter():
    """Controls EFCrafter in FPGA device.
    """

    def __init__(self, xsdb: pyxsdb.PyXsdb, xsdb_target: int, addr_table: TsnEfccAddressTable):
        """initialize EFCrafter.

        Args:
            xsdb (pyxsdb.PyXsdb): PyXsdb object (connect() method must be called before)
            xsdb_target (int): The AXI JTAG target of TSN-EFCC.
            addr_table (TsnEfccAddressTable): The address table of TSN-EFCC.
        """
        self.xsdb = xsdb
        self.xsdb_target = xsdb_target
        self.addr_table = addr_table
        self.ctrl_addr = addr_table.ef_crafter
        self.ram_addrs = addr_table.ef_crafter_buffers
        self.num_ports = len(self.ram_addrs)
        self.commit_hash = addr_table.commit_hash

    def set_frame(self, port: int, index: int, frame: Frame) -> None:
        """Set frame object into frame buffer.

        Args:
            port (int): Output port of EFCrafter.
            index (int): Frame buffer index.
            frame (Frame): Frame object.

        Returns:
            None: none
        """
        self._set_xsdb_target()
        regval = frame.reg_format()

        ram_start = self.ram_addrs[port] + index * 16
        for i, val in enumerate(regval):
            self.xsdb.mwr(ram_start + i * 4, val)

    def get_frame(self, port: int, index: int, name: str = 'Frame') -> Frame:
        """Get frame object into frame buffer.

        Args:
            port (int): Output port of EFCrafter.
            index (int): Frame buffer index.
            name (str): The name of frame object. This name is set to return object.

        Returns:
            Frame: frame object
        """
        self._set_xsdb_target()

        ram_start = self.ram_addrs[port] + index * 16
        regval = []
        for i in range(4):
            regval.append(self.xsdb.mrd(ram_start + i * 4))

        frame = Frame(name)
        frame.init_from_register(regval)
        return frame

    def get_frames(self, port: int, start: int = 0, max_num: int = 10000) -> List[Frame]:
        """Get a sequence of frame objects from frame buffer.

        Args:
            port (int): Output port of EFCrafter.
            start (int): The start index of sequence.
            max_num (int): The maximum number of frames to be read. If reached to EOL frame, no further frames are added to return sequence.

        Returns:
            List[Frame]: a sequence of frame object.
        """
        self._set_xsdb_target()

        frames = []
        for i in range(start, start + max_num):
            frame = self.get_frame(port, i, f'Frame{i:04d}')
            frames.append(frame)

            if frame.is_eol():
                break

        return frames

    def get_status(self, port: int) -> Dict[str, int]:
        """Get the device status of EFCrafter.

        Args:
            port (int): Output port of EFCrafter.

        Returns:
            Dict[str, str or int]: Returns a dictionary of status. This dictionary contains the following values:
                - 'status': 'Sending frames' or 'Stopped' (str)
                - 'repeat': 'enable' or 'disable' (str)
                - 'loopcounter': loop counter value (int)
                - 'framecounter': frame counter value (int)
                - 'com_running': debug information (int)
                - 'com_repeat': debug information (int)
                - 'com_fno_reset': debug information (int)
                - 'sta_send_done': debug information (int)
                - 'sta_repeat_done': debug information (int)
                - 'sta_counter_reset_done': debug information (int)
        """
        self._set_xsdb_target()
        cmd = self.xsdb.mrd(self.ctrl_addr)
        stat = self.xsdb.mrd(self.ctrl_addr + port * 16 + 4)
        fcnt = self.xsdb.mrd(self.ctrl_addr + port * 16 + 8)
        loop = self.xsdb.mrd(self.ctrl_addr + port * 16 + 12)

        return {'status': 'Sending frames' if (stat & 0x1) == 1 else 'Stopped',
                'repeat': 'enable' if (stat & 0x2) == 2 else 'disable',
                'loopcounter': loop,
                'framecounter': fcnt,
                'com_running': (cmd & (1 << (port * 3))) != 0,
                'com_repeat': (cmd & (2 << (port * 3))) != 0,
                'com_fno_reset': (cmd & (3 << (port * 3))) != 0,
                'sta_send_done': (stat & 4) != 0,
                'sta_repeat_done': (stat & 8) != 0,
                'sta_counter_reset_done': (stat & 16) != 0,
                }

    def wait(self, port: int, timeout_sec: float = 10) -> None:
        """Wait until ef_crafter is stopped.

        Note:
            If repeat flag is set, ef_crafter never stops.

        Args:
            port (int): Output port of EFCrafter.
            timeout_sec (float): Timeout seconds.

        Returns:
            None: none

        Raises:
            RuntimeError: If timeout is expired.
        """
        self._set_xsdb_target()
        start = time.perf_counter()
        while True:
            stat = self.xsdb.mrd(self.ctrl_addr + port * 16 + 4)
            if (stat & 0x1) == 0:
                # stopped
                break
            if time.perf_counter() - start > timeout_sec:
                raise RuntimeError('timeout expired')
        return

    def wait_until(self, port: int, framecounter_thresh: int, timeout_sec: float = 10) -> None:
        """Wait until ef_crafter sends framecounter_thresh frames.

        Args:
            port (int): Output port of EFCrafter.
            framecounter_thresh (int): The number of frames to wait.
            timeout_sec (float): Timeout seconds.

        Returns:
            None: none

        Raises:
            RuntimeError: If timeout is expired.
        """
        self._set_xsdb_target()
        start = time.perf_counter()
        while True:
            fcnt = self.xsdb.mrd(self.ctrl_addr + port * 16 + 8)
            if fcnt >= framecounter_thresh:
                break
            if time.perf_counter() - start > timeout_sec:
                raise RuntimeError('timeout expired')
        return

    def reset(self, mask: int) -> None:
        """Reset ef_crafter.

        Args:
            mask (int): A bit mask of ef_crafter's port. If set to 0b0101, port[2] and port[0] is reset.

        Returns:
            None: none
        """
        self._set_xsdb_target()
        cmd_val = self.xsdb.mrd(self.ctrl_addr)
        cmd_val &= 0xFF000000
        cmd_val |= self._adjust_mask(mask, 3, 2)
        self.xsdb.mwr(self.ctrl_addr, cmd_val)

    def set_repeat(self, mask: int) -> None:
        """Enable repeat function.

        Note:
            To clear repeat flags, call reset function.

        Args:
            mask (int): A bit mask of ef_crafter's port. If set to 0b0101, port[2] and port[0] is repeat enabled.

        Returns:
            None: none
        """
        self._set_xsdb_target()
        cmd_val = self.xsdb.mrd(self.ctrl_addr)
        # restore original value other than repeat field
        cmd_val &= ~self._adjust_mask((1<<self.num_ports-1), 3, 1)
        cmd_val |= self._adjust_mask(mask, 3, 1)
        self.xsdb.mwr(self.ctrl_addr, cmd_val)

    def start(self, mask: int) -> None:
        """Start transfer.

        Args:
            mask (int): A bit mask of ef_crafter's port. If set to 0b0101, port[2] and port[0] is started.

        Returns:
            None: none
        """
        self._set_xsdb_target()
        cmd_val = self.xsdb.mrd(self.ctrl_addr)
        # restore original value other than repeat field
        cmd_val &= ~self._adjust_mask((1<<self.num_ports-1), 3, 0)
        cmd_val |= self._adjust_mask(mask, 3, 0)
        self.xsdb.mwr(self.ctrl_addr, cmd_val)

    def set_mac_address(self, port: int, index: int, val: str) -> None:
        """Set EFCrafter's MAC address table.

        Args:
            port (int): Output port of EFCrafter.
            index (int): index of the address table (0~255)
            val (str): The MAC address value. format: aa:bb:cc:dd:ee:ff

        Returns:
            None: none
        """

        # modify mac address to integer
        mac_int = int(val.replace(':', ''), 16)

        self._set_xsdb_target()
        addr = self.addr_table.ef_crafter_mac_tables[port]
        addr += index * 8
        self.xsdb.mwr(addr, mac_int & 0xffffffff)
        self.xsdb.mwr(addr + 4, mac_int >> 32)

    def get_mac_address(self, port: int, index: int) -> str:
        """Get MAC address from EFCrafter's MAC address table.

        Args:
            port (int): Output port of EFCrafter.
            index (int): index of the address table (0~255)

        Returns:
            str: MAC address. format: aa:bb:cc:dd:ee:ff
        """

        self._set_xsdb_target()
        addr = self.addr_table.ef_crafter_mac_tables[port]
        addr += index * 8
        mac_int = self.xsdb.mrd(addr)
        mac_int |= self.xsdb.mrd(addr + 4) << 32
        mac_hex = "{:012x}".format(mac_int)
        mac_str = ":".join(mac_hex[i:i+2] for i in range(0, len(mac_hex), 2))
        return mac_str

    def set_ip_address(self, port: int, index: int, val: str) -> None:
        """Set EFCrafter's IP address table.

        Args:
            port (int): Output port of EFCrafter.
            index (int): index of the address table (0~255)
            val (str): The IP address value. format: xxx.yyy.www.zzz

        Returns:
            None: none
        """

        # modify ip address to integer
        ip_int = int(ipaddress.ip_address(val))

        self._set_xsdb_target()
        addr = self.addr_table.ef_crafter_ip_tables[port]
        addr += index * 4
        self.xsdb.mwr(addr, ip_int)

    def get_ip_address(self, port: int, index: int) -> str:
        """Get IP address from EFCrafter's IP address table.

        Args:
            port (int): Output port of EFCrafter.
            index (int): index of the address table (0~255)

        Returns:
            str: IP address. format: xxx.yyy.www.zzz
        """

        self._set_xsdb_target()
        addr = self.addr_table.ef_crafter_ip_tables[port]
        addr += index * 4
        ip_int = self.xsdb.mrd(addr)
        ip_str = str(ipaddress.ip_address(ip_int))
        return ip_str

    def get_commit_hash(self) -> int:
        """Get commit hash used to implement the current bitstream

        Args:
            None: none

        Returns:
            int: 8-digit Git commit hash
        """
        hash = self.commit_hash
        self._set_xsdb_target()
        return hex(self.xsdb.mrd(hash))

    def _adjust_mask(self, mask, interval, offset):
        out_mask = 0
        ptr = offset
        while mask != 0:
            if mask & 1:
                out_mask |= 1 << ptr

            mask >>= 1
            ptr += interval

        return out_mask

    def _set_xsdb_target(self):
        self.xsdb.target(self.xsdb_target)
